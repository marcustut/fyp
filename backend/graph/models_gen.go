// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/marcustut/fyp/backend/ent/schema/ulid"
)

// UserWhereInput is used for filtering User objects.
// Input was generated by ent.
type UserWhereInput struct {
	Not *UserWhereInput   `json:"not"`
	And []*UserWhereInput `json:"and"`
	Or  []*UserWhereInput `json:"or"`
	// username field predicates
	Username             *string  `json:"username"`
	UsernameNeq          *string  `json:"usernameNEQ"`
	UsernameIn           []string `json:"usernameIn"`
	UsernameNotIn        []string `json:"usernameNotIn"`
	UsernameGt           *string  `json:"usernameGT"`
	UsernameGte          *string  `json:"usernameGTE"`
	UsernameLt           *string  `json:"usernameLT"`
	UsernameLte          *string  `json:"usernameLTE"`
	UsernameContains     *string  `json:"usernameContains"`
	UsernameHasPrefix    *string  `json:"usernameHasPrefix"`
	UsernameHasSuffix    *string  `json:"usernameHasSuffix"`
	UsernameEqualFold    *string  `json:"usernameEqualFold"`
	UsernameContainsFold *string  `json:"usernameContainsFold"`
	// email field predicates
	Email             *string  `json:"email"`
	EmailNeq          *string  `json:"emailNEQ"`
	EmailIn           []string `json:"emailIn"`
	EmailNotIn        []string `json:"emailNotIn"`
	EmailGt           *string  `json:"emailGT"`
	EmailGte          *string  `json:"emailGTE"`
	EmailLt           *string  `json:"emailLT"`
	EmailLte          *string  `json:"emailLTE"`
	EmailContains     *string  `json:"emailContains"`
	EmailHasPrefix    *string  `json:"emailHasPrefix"`
	EmailHasSuffix    *string  `json:"emailHasSuffix"`
	EmailEqualFold    *string  `json:"emailEqualFold"`
	EmailContainsFold *string  `json:"emailContainsFold"`
	// full_name field predicates
	FullName             *string  `json:"fullName"`
	FullNameNeq          *string  `json:"fullNameNEQ"`
	FullNameIn           []string `json:"fullNameIn"`
	FullNameNotIn        []string `json:"fullNameNotIn"`
	FullNameGt           *string  `json:"fullNameGT"`
	FullNameGte          *string  `json:"fullNameGTE"`
	FullNameLt           *string  `json:"fullNameLT"`
	FullNameLte          *string  `json:"fullNameLTE"`
	FullNameContains     *string  `json:"fullNameContains"`
	FullNameHasPrefix    *string  `json:"fullNameHasPrefix"`
	FullNameHasSuffix    *string  `json:"fullNameHasSuffix"`
	FullNameIsNil        *bool    `json:"fullNameIsNil"`
	FullNameNotNil       *bool    `json:"fullNameNotNil"`
	FullNameEqualFold    *string  `json:"fullNameEqualFold"`
	FullNameContainsFold *string  `json:"fullNameContainsFold"`
	// avatar_url field predicates
	AvatarURL             *string  `json:"avatarURL"`
	AvatarURLNeq          *string  `json:"avatarURLNEQ"`
	AvatarURLIn           []string `json:"avatarURLIn"`
	AvatarURLNotIn        []string `json:"avatarURLNotIn"`
	AvatarURLGt           *string  `json:"avatarURLGT"`
	AvatarURLGte          *string  `json:"avatarURLGTE"`
	AvatarURLLt           *string  `json:"avatarURLLT"`
	AvatarURLLte          *string  `json:"avatarURLLTE"`
	AvatarURLContains     *string  `json:"avatarURLContains"`
	AvatarURLHasPrefix    *string  `json:"avatarURLHasPrefix"`
	AvatarURLHasSuffix    *string  `json:"avatarURLHasSuffix"`
	AvatarURLIsNil        *bool    `json:"avatarURLIsNil"`
	AvatarURLNotNil       *bool    `json:"avatarURLNotNil"`
	AvatarURLEqualFold    *string  `json:"avatarURLEqualFold"`
	AvatarURLContainsFold *string  `json:"avatarURLContainsFold"`
	// bio field predicates
	Bio             *string  `json:"bio"`
	BioNeq          *string  `json:"bioNEQ"`
	BioIn           []string `json:"bioIn"`
	BioNotIn        []string `json:"bioNotIn"`
	BioGt           *string  `json:"bioGT"`
	BioGte          *string  `json:"bioGTE"`
	BioLt           *string  `json:"bioLT"`
	BioLte          *string  `json:"bioLTE"`
	BioContains     *string  `json:"bioContains"`
	BioHasPrefix    *string  `json:"bioHasPrefix"`
	BioHasSuffix    *string  `json:"bioHasSuffix"`
	BioIsNil        *bool    `json:"bioIsNil"`
	BioNotNil       *bool    `json:"bioNotNil"`
	BioEqualFold    *string  `json:"bioEqualFold"`
	BioContainsFold *string  `json:"bioContainsFold"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ"`
	CreatedAtIn    []*time.Time `json:"createdAtIn"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn"`
	CreatedAtGt    *time.Time   `json:"createdAtGT"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE"`
	CreatedAtLt    *time.Time   `json:"createdAtLT"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE"`
	// id field predicates
	ID      *ulid.ID  `json:"id"`
	IDNeq   *ulid.ID  `json:"idNEQ"`
	IDIn    []ulid.ID `json:"idIn"`
	IDNotIn []ulid.ID `json:"idNotIn"`
	IDGt    *ulid.ID  `json:"idGT"`
	IDGte   *ulid.ID  `json:"idGTE"`
	IDLt    *ulid.ID  `json:"idLT"`
	IDLte   *ulid.ID  `json:"idLTE"`
}

type OrderDirection string

const (
	OrderDirectionAsc  OrderDirection = "ASC"
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
