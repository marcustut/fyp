// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"time"

	"github.com/marcustut/fyp/backend/ent/instance"
	"github.com/marcustut/fyp/backend/ent/link"
	"github.com/marcustut/fyp/backend/ent/predicate"
	"github.com/marcustut/fyp/backend/ent/schema/ulid"
	"github.com/marcustut/fyp/backend/ent/slide"
	"github.com/marcustut/fyp/backend/ent/user"
)

// InstanceWhereInput represents a where input for filtering Instance queries.
type InstanceWhereInput struct {
	Not *InstanceWhereInput   `json:"not,omitempty"`
	Or  []*InstanceWhereInput `json:"or,omitempty"`
	And []*InstanceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *ulid.ID  `json:"id,omitempty"`
	IDNEQ   *ulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []ulid.ID `json:"idIn,omitempty"`
	IDNotIn []ulid.ID `json:"idNotIn,omitempty"`
	IDGT    *ulid.ID  `json:"idGT,omitempty"`
	IDGTE   *ulid.ID  `json:"idGTE,omitempty"`
	IDLT    *ulid.ID  `json:"idLT,omitempty"`
	IDLTE   *ulid.ID  `json:"idLTE,omitempty"`

	// "instance_id" field predicates.
	InstanceID             *string  `json:"instanceID,omitempty"`
	InstanceIDNEQ          *string  `json:"instanceIDNEQ,omitempty"`
	InstanceIDIn           []string `json:"instanceIDIn,omitempty"`
	InstanceIDNotIn        []string `json:"instanceIDNotIn,omitempty"`
	InstanceIDGT           *string  `json:"instanceIDGT,omitempty"`
	InstanceIDGTE          *string  `json:"instanceIDGTE,omitempty"`
	InstanceIDLT           *string  `json:"instanceIDLT,omitempty"`
	InstanceIDLTE          *string  `json:"instanceIDLTE,omitempty"`
	InstanceIDContains     *string  `json:"instanceIDContains,omitempty"`
	InstanceIDHasPrefix    *string  `json:"instanceIDHasPrefix,omitempty"`
	InstanceIDHasSuffix    *string  `json:"instanceIDHasSuffix,omitempty"`
	InstanceIDEqualFold    *string  `json:"instanceIDEqualFold,omitempty"`
	InstanceIDContainsFold *string  `json:"instanceIDContainsFold,omitempty"`

	// "instance_type" field predicates.
	InstanceType             *string  `json:"instanceType,omitempty"`
	InstanceTypeNEQ          *string  `json:"instanceTypeNEQ,omitempty"`
	InstanceTypeIn           []string `json:"instanceTypeIn,omitempty"`
	InstanceTypeNotIn        []string `json:"instanceTypeNotIn,omitempty"`
	InstanceTypeGT           *string  `json:"instanceTypeGT,omitempty"`
	InstanceTypeGTE          *string  `json:"instanceTypeGTE,omitempty"`
	InstanceTypeLT           *string  `json:"instanceTypeLT,omitempty"`
	InstanceTypeLTE          *string  `json:"instanceTypeLTE,omitempty"`
	InstanceTypeContains     *string  `json:"instanceTypeContains,omitempty"`
	InstanceTypeHasPrefix    *string  `json:"instanceTypeHasPrefix,omitempty"`
	InstanceTypeHasSuffix    *string  `json:"instanceTypeHasSuffix,omitempty"`
	InstanceTypeEqualFold    *string  `json:"instanceTypeEqualFold,omitempty"`
	InstanceTypeContainsFold *string  `json:"instanceTypeContainsFold,omitempty"`

	// "private_dns_name" field predicates.
	PrivateDNSName             *string  `json:"privateDNSName,omitempty"`
	PrivateDNSNameNEQ          *string  `json:"privateDNSNameNEQ,omitempty"`
	PrivateDNSNameIn           []string `json:"privateDNSNameIn,omitempty"`
	PrivateDNSNameNotIn        []string `json:"privateDNSNameNotIn,omitempty"`
	PrivateDNSNameGT           *string  `json:"privateDNSNameGT,omitempty"`
	PrivateDNSNameGTE          *string  `json:"privateDNSNameGTE,omitempty"`
	PrivateDNSNameLT           *string  `json:"privateDNSNameLT,omitempty"`
	PrivateDNSNameLTE          *string  `json:"privateDNSNameLTE,omitempty"`
	PrivateDNSNameContains     *string  `json:"privateDNSNameContains,omitempty"`
	PrivateDNSNameHasPrefix    *string  `json:"privateDNSNameHasPrefix,omitempty"`
	PrivateDNSNameHasSuffix    *string  `json:"privateDNSNameHasSuffix,omitempty"`
	PrivateDNSNameEqualFold    *string  `json:"privateDNSNameEqualFold,omitempty"`
	PrivateDNSNameContainsFold *string  `json:"privateDNSNameContainsFold,omitempty"`

	// "private_ip_address" field predicates.
	PrivateIPAddress             *string  `json:"privateIPAddress,omitempty"`
	PrivateIPAddressNEQ          *string  `json:"privateIPAddressNEQ,omitempty"`
	PrivateIPAddressIn           []string `json:"privateIPAddressIn,omitempty"`
	PrivateIPAddressNotIn        []string `json:"privateIPAddressNotIn,omitempty"`
	PrivateIPAddressGT           *string  `json:"privateIPAddressGT,omitempty"`
	PrivateIPAddressGTE          *string  `json:"privateIPAddressGTE,omitempty"`
	PrivateIPAddressLT           *string  `json:"privateIPAddressLT,omitempty"`
	PrivateIPAddressLTE          *string  `json:"privateIPAddressLTE,omitempty"`
	PrivateIPAddressContains     *string  `json:"privateIPAddressContains,omitempty"`
	PrivateIPAddressHasPrefix    *string  `json:"privateIPAddressHasPrefix,omitempty"`
	PrivateIPAddressHasSuffix    *string  `json:"privateIPAddressHasSuffix,omitempty"`
	PrivateIPAddressEqualFold    *string  `json:"privateIPAddressEqualFold,omitempty"`
	PrivateIPAddressContainsFold *string  `json:"privateIPAddressContainsFold,omitempty"`

	// "public_dns_name" field predicates.
	PublicDNSName             *string  `json:"publicDNSName,omitempty"`
	PublicDNSNameNEQ          *string  `json:"publicDNSNameNEQ,omitempty"`
	PublicDNSNameIn           []string `json:"publicDNSNameIn,omitempty"`
	PublicDNSNameNotIn        []string `json:"publicDNSNameNotIn,omitempty"`
	PublicDNSNameGT           *string  `json:"publicDNSNameGT,omitempty"`
	PublicDNSNameGTE          *string  `json:"publicDNSNameGTE,omitempty"`
	PublicDNSNameLT           *string  `json:"publicDNSNameLT,omitempty"`
	PublicDNSNameLTE          *string  `json:"publicDNSNameLTE,omitempty"`
	PublicDNSNameContains     *string  `json:"publicDNSNameContains,omitempty"`
	PublicDNSNameHasPrefix    *string  `json:"publicDNSNameHasPrefix,omitempty"`
	PublicDNSNameHasSuffix    *string  `json:"publicDNSNameHasSuffix,omitempty"`
	PublicDNSNameEqualFold    *string  `json:"publicDNSNameEqualFold,omitempty"`
	PublicDNSNameContainsFold *string  `json:"publicDNSNameContainsFold,omitempty"`

	// "public_ip_address" field predicates.
	PublicIPAddress             *string  `json:"publicIPAddress,omitempty"`
	PublicIPAddressNEQ          *string  `json:"publicIPAddressNEQ,omitempty"`
	PublicIPAddressIn           []string `json:"publicIPAddressIn,omitempty"`
	PublicIPAddressNotIn        []string `json:"publicIPAddressNotIn,omitempty"`
	PublicIPAddressGT           *string  `json:"publicIPAddressGT,omitempty"`
	PublicIPAddressGTE          *string  `json:"publicIPAddressGTE,omitempty"`
	PublicIPAddressLT           *string  `json:"publicIPAddressLT,omitempty"`
	PublicIPAddressLTE          *string  `json:"publicIPAddressLTE,omitempty"`
	PublicIPAddressContains     *string  `json:"publicIPAddressContains,omitempty"`
	PublicIPAddressHasPrefix    *string  `json:"publicIPAddressHasPrefix,omitempty"`
	PublicIPAddressHasSuffix    *string  `json:"publicIPAddressHasSuffix,omitempty"`
	PublicIPAddressEqualFold    *string  `json:"publicIPAddressEqualFold,omitempty"`
	PublicIPAddressContainsFold *string  `json:"publicIPAddressContainsFold,omitempty"`

	// "image_id" field predicates.
	ImageID             *string  `json:"imageID,omitempty"`
	ImageIDNEQ          *string  `json:"imageIDNEQ,omitempty"`
	ImageIDIn           []string `json:"imageIDIn,omitempty"`
	ImageIDNotIn        []string `json:"imageIDNotIn,omitempty"`
	ImageIDGT           *string  `json:"imageIDGT,omitempty"`
	ImageIDGTE          *string  `json:"imageIDGTE,omitempty"`
	ImageIDLT           *string  `json:"imageIDLT,omitempty"`
	ImageIDLTE          *string  `json:"imageIDLTE,omitempty"`
	ImageIDContains     *string  `json:"imageIDContains,omitempty"`
	ImageIDHasPrefix    *string  `json:"imageIDHasPrefix,omitempty"`
	ImageIDHasSuffix    *string  `json:"imageIDHasSuffix,omitempty"`
	ImageIDEqualFold    *string  `json:"imageIDEqualFold,omitempty"`
	ImageIDContainsFold *string  `json:"imageIDContainsFold,omitempty"`

	// "architecture" field predicates.
	Architecture             *string  `json:"architecture,omitempty"`
	ArchitectureNEQ          *string  `json:"architectureNEQ,omitempty"`
	ArchitectureIn           []string `json:"architectureIn,omitempty"`
	ArchitectureNotIn        []string `json:"architectureNotIn,omitempty"`
	ArchitectureGT           *string  `json:"architectureGT,omitempty"`
	ArchitectureGTE          *string  `json:"architectureGTE,omitempty"`
	ArchitectureLT           *string  `json:"architectureLT,omitempty"`
	ArchitectureLTE          *string  `json:"architectureLTE,omitempty"`
	ArchitectureContains     *string  `json:"architectureContains,omitempty"`
	ArchitectureHasPrefix    *string  `json:"architectureHasPrefix,omitempty"`
	ArchitectureHasSuffix    *string  `json:"architectureHasSuffix,omitempty"`
	ArchitectureEqualFold    *string  `json:"architectureEqualFold,omitempty"`
	ArchitectureContainsFold *string  `json:"architectureContainsFold,omitempty"`

	// "availability_zone" field predicates.
	AvailabilityZone             *string  `json:"availabilityZone,omitempty"`
	AvailabilityZoneNEQ          *string  `json:"availabilityZoneNEQ,omitempty"`
	AvailabilityZoneIn           []string `json:"availabilityZoneIn,omitempty"`
	AvailabilityZoneNotIn        []string `json:"availabilityZoneNotIn,omitempty"`
	AvailabilityZoneGT           *string  `json:"availabilityZoneGT,omitempty"`
	AvailabilityZoneGTE          *string  `json:"availabilityZoneGTE,omitempty"`
	AvailabilityZoneLT           *string  `json:"availabilityZoneLT,omitempty"`
	AvailabilityZoneLTE          *string  `json:"availabilityZoneLTE,omitempty"`
	AvailabilityZoneContains     *string  `json:"availabilityZoneContains,omitempty"`
	AvailabilityZoneHasPrefix    *string  `json:"availabilityZoneHasPrefix,omitempty"`
	AvailabilityZoneHasSuffix    *string  `json:"availabilityZoneHasSuffix,omitempty"`
	AvailabilityZoneEqualFold    *string  `json:"availabilityZoneEqualFold,omitempty"`
	AvailabilityZoneContainsFold *string  `json:"availabilityZoneContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "slide" edge predicates.
	HasSlide     *bool              `json:"hasSlide,omitempty"`
	HasSlideWith []*SlideWhereInput `json:"hasSlideWith,omitempty"`
}

// Filter applies the InstanceWhereInput filter on the InstanceQuery builder.
func (i *InstanceWhereInput) Filter(q *InstanceQuery) (*InstanceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering instances.
// An error is returned if the input is empty or invalid.
func (i *InstanceWhereInput) P() (predicate.Instance, error) {
	var predicates []predicate.Instance
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, instance.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Instance, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, instance.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Instance, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, instance.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, instance.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, instance.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, instance.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, instance.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, instance.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, instance.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, instance.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, instance.IDLTE(*i.IDLTE))
	}
	if i.InstanceID != nil {
		predicates = append(predicates, instance.InstanceIDEQ(*i.InstanceID))
	}
	if i.InstanceIDNEQ != nil {
		predicates = append(predicates, instance.InstanceIDNEQ(*i.InstanceIDNEQ))
	}
	if len(i.InstanceIDIn) > 0 {
		predicates = append(predicates, instance.InstanceIDIn(i.InstanceIDIn...))
	}
	if len(i.InstanceIDNotIn) > 0 {
		predicates = append(predicates, instance.InstanceIDNotIn(i.InstanceIDNotIn...))
	}
	if i.InstanceIDGT != nil {
		predicates = append(predicates, instance.InstanceIDGT(*i.InstanceIDGT))
	}
	if i.InstanceIDGTE != nil {
		predicates = append(predicates, instance.InstanceIDGTE(*i.InstanceIDGTE))
	}
	if i.InstanceIDLT != nil {
		predicates = append(predicates, instance.InstanceIDLT(*i.InstanceIDLT))
	}
	if i.InstanceIDLTE != nil {
		predicates = append(predicates, instance.InstanceIDLTE(*i.InstanceIDLTE))
	}
	if i.InstanceIDContains != nil {
		predicates = append(predicates, instance.InstanceIDContains(*i.InstanceIDContains))
	}
	if i.InstanceIDHasPrefix != nil {
		predicates = append(predicates, instance.InstanceIDHasPrefix(*i.InstanceIDHasPrefix))
	}
	if i.InstanceIDHasSuffix != nil {
		predicates = append(predicates, instance.InstanceIDHasSuffix(*i.InstanceIDHasSuffix))
	}
	if i.InstanceIDEqualFold != nil {
		predicates = append(predicates, instance.InstanceIDEqualFold(*i.InstanceIDEqualFold))
	}
	if i.InstanceIDContainsFold != nil {
		predicates = append(predicates, instance.InstanceIDContainsFold(*i.InstanceIDContainsFold))
	}
	if i.InstanceType != nil {
		predicates = append(predicates, instance.InstanceTypeEQ(*i.InstanceType))
	}
	if i.InstanceTypeNEQ != nil {
		predicates = append(predicates, instance.InstanceTypeNEQ(*i.InstanceTypeNEQ))
	}
	if len(i.InstanceTypeIn) > 0 {
		predicates = append(predicates, instance.InstanceTypeIn(i.InstanceTypeIn...))
	}
	if len(i.InstanceTypeNotIn) > 0 {
		predicates = append(predicates, instance.InstanceTypeNotIn(i.InstanceTypeNotIn...))
	}
	if i.InstanceTypeGT != nil {
		predicates = append(predicates, instance.InstanceTypeGT(*i.InstanceTypeGT))
	}
	if i.InstanceTypeGTE != nil {
		predicates = append(predicates, instance.InstanceTypeGTE(*i.InstanceTypeGTE))
	}
	if i.InstanceTypeLT != nil {
		predicates = append(predicates, instance.InstanceTypeLT(*i.InstanceTypeLT))
	}
	if i.InstanceTypeLTE != nil {
		predicates = append(predicates, instance.InstanceTypeLTE(*i.InstanceTypeLTE))
	}
	if i.InstanceTypeContains != nil {
		predicates = append(predicates, instance.InstanceTypeContains(*i.InstanceTypeContains))
	}
	if i.InstanceTypeHasPrefix != nil {
		predicates = append(predicates, instance.InstanceTypeHasPrefix(*i.InstanceTypeHasPrefix))
	}
	if i.InstanceTypeHasSuffix != nil {
		predicates = append(predicates, instance.InstanceTypeHasSuffix(*i.InstanceTypeHasSuffix))
	}
	if i.InstanceTypeEqualFold != nil {
		predicates = append(predicates, instance.InstanceTypeEqualFold(*i.InstanceTypeEqualFold))
	}
	if i.InstanceTypeContainsFold != nil {
		predicates = append(predicates, instance.InstanceTypeContainsFold(*i.InstanceTypeContainsFold))
	}
	if i.PrivateDNSName != nil {
		predicates = append(predicates, instance.PrivateDNSNameEQ(*i.PrivateDNSName))
	}
	if i.PrivateDNSNameNEQ != nil {
		predicates = append(predicates, instance.PrivateDNSNameNEQ(*i.PrivateDNSNameNEQ))
	}
	if len(i.PrivateDNSNameIn) > 0 {
		predicates = append(predicates, instance.PrivateDNSNameIn(i.PrivateDNSNameIn...))
	}
	if len(i.PrivateDNSNameNotIn) > 0 {
		predicates = append(predicates, instance.PrivateDNSNameNotIn(i.PrivateDNSNameNotIn...))
	}
	if i.PrivateDNSNameGT != nil {
		predicates = append(predicates, instance.PrivateDNSNameGT(*i.PrivateDNSNameGT))
	}
	if i.PrivateDNSNameGTE != nil {
		predicates = append(predicates, instance.PrivateDNSNameGTE(*i.PrivateDNSNameGTE))
	}
	if i.PrivateDNSNameLT != nil {
		predicates = append(predicates, instance.PrivateDNSNameLT(*i.PrivateDNSNameLT))
	}
	if i.PrivateDNSNameLTE != nil {
		predicates = append(predicates, instance.PrivateDNSNameLTE(*i.PrivateDNSNameLTE))
	}
	if i.PrivateDNSNameContains != nil {
		predicates = append(predicates, instance.PrivateDNSNameContains(*i.PrivateDNSNameContains))
	}
	if i.PrivateDNSNameHasPrefix != nil {
		predicates = append(predicates, instance.PrivateDNSNameHasPrefix(*i.PrivateDNSNameHasPrefix))
	}
	if i.PrivateDNSNameHasSuffix != nil {
		predicates = append(predicates, instance.PrivateDNSNameHasSuffix(*i.PrivateDNSNameHasSuffix))
	}
	if i.PrivateDNSNameEqualFold != nil {
		predicates = append(predicates, instance.PrivateDNSNameEqualFold(*i.PrivateDNSNameEqualFold))
	}
	if i.PrivateDNSNameContainsFold != nil {
		predicates = append(predicates, instance.PrivateDNSNameContainsFold(*i.PrivateDNSNameContainsFold))
	}
	if i.PrivateIPAddress != nil {
		predicates = append(predicates, instance.PrivateIPAddressEQ(*i.PrivateIPAddress))
	}
	if i.PrivateIPAddressNEQ != nil {
		predicates = append(predicates, instance.PrivateIPAddressNEQ(*i.PrivateIPAddressNEQ))
	}
	if len(i.PrivateIPAddressIn) > 0 {
		predicates = append(predicates, instance.PrivateIPAddressIn(i.PrivateIPAddressIn...))
	}
	if len(i.PrivateIPAddressNotIn) > 0 {
		predicates = append(predicates, instance.PrivateIPAddressNotIn(i.PrivateIPAddressNotIn...))
	}
	if i.PrivateIPAddressGT != nil {
		predicates = append(predicates, instance.PrivateIPAddressGT(*i.PrivateIPAddressGT))
	}
	if i.PrivateIPAddressGTE != nil {
		predicates = append(predicates, instance.PrivateIPAddressGTE(*i.PrivateIPAddressGTE))
	}
	if i.PrivateIPAddressLT != nil {
		predicates = append(predicates, instance.PrivateIPAddressLT(*i.PrivateIPAddressLT))
	}
	if i.PrivateIPAddressLTE != nil {
		predicates = append(predicates, instance.PrivateIPAddressLTE(*i.PrivateIPAddressLTE))
	}
	if i.PrivateIPAddressContains != nil {
		predicates = append(predicates, instance.PrivateIPAddressContains(*i.PrivateIPAddressContains))
	}
	if i.PrivateIPAddressHasPrefix != nil {
		predicates = append(predicates, instance.PrivateIPAddressHasPrefix(*i.PrivateIPAddressHasPrefix))
	}
	if i.PrivateIPAddressHasSuffix != nil {
		predicates = append(predicates, instance.PrivateIPAddressHasSuffix(*i.PrivateIPAddressHasSuffix))
	}
	if i.PrivateIPAddressEqualFold != nil {
		predicates = append(predicates, instance.PrivateIPAddressEqualFold(*i.PrivateIPAddressEqualFold))
	}
	if i.PrivateIPAddressContainsFold != nil {
		predicates = append(predicates, instance.PrivateIPAddressContainsFold(*i.PrivateIPAddressContainsFold))
	}
	if i.PublicDNSName != nil {
		predicates = append(predicates, instance.PublicDNSNameEQ(*i.PublicDNSName))
	}
	if i.PublicDNSNameNEQ != nil {
		predicates = append(predicates, instance.PublicDNSNameNEQ(*i.PublicDNSNameNEQ))
	}
	if len(i.PublicDNSNameIn) > 0 {
		predicates = append(predicates, instance.PublicDNSNameIn(i.PublicDNSNameIn...))
	}
	if len(i.PublicDNSNameNotIn) > 0 {
		predicates = append(predicates, instance.PublicDNSNameNotIn(i.PublicDNSNameNotIn...))
	}
	if i.PublicDNSNameGT != nil {
		predicates = append(predicates, instance.PublicDNSNameGT(*i.PublicDNSNameGT))
	}
	if i.PublicDNSNameGTE != nil {
		predicates = append(predicates, instance.PublicDNSNameGTE(*i.PublicDNSNameGTE))
	}
	if i.PublicDNSNameLT != nil {
		predicates = append(predicates, instance.PublicDNSNameLT(*i.PublicDNSNameLT))
	}
	if i.PublicDNSNameLTE != nil {
		predicates = append(predicates, instance.PublicDNSNameLTE(*i.PublicDNSNameLTE))
	}
	if i.PublicDNSNameContains != nil {
		predicates = append(predicates, instance.PublicDNSNameContains(*i.PublicDNSNameContains))
	}
	if i.PublicDNSNameHasPrefix != nil {
		predicates = append(predicates, instance.PublicDNSNameHasPrefix(*i.PublicDNSNameHasPrefix))
	}
	if i.PublicDNSNameHasSuffix != nil {
		predicates = append(predicates, instance.PublicDNSNameHasSuffix(*i.PublicDNSNameHasSuffix))
	}
	if i.PublicDNSNameEqualFold != nil {
		predicates = append(predicates, instance.PublicDNSNameEqualFold(*i.PublicDNSNameEqualFold))
	}
	if i.PublicDNSNameContainsFold != nil {
		predicates = append(predicates, instance.PublicDNSNameContainsFold(*i.PublicDNSNameContainsFold))
	}
	if i.PublicIPAddress != nil {
		predicates = append(predicates, instance.PublicIPAddressEQ(*i.PublicIPAddress))
	}
	if i.PublicIPAddressNEQ != nil {
		predicates = append(predicates, instance.PublicIPAddressNEQ(*i.PublicIPAddressNEQ))
	}
	if len(i.PublicIPAddressIn) > 0 {
		predicates = append(predicates, instance.PublicIPAddressIn(i.PublicIPAddressIn...))
	}
	if len(i.PublicIPAddressNotIn) > 0 {
		predicates = append(predicates, instance.PublicIPAddressNotIn(i.PublicIPAddressNotIn...))
	}
	if i.PublicIPAddressGT != nil {
		predicates = append(predicates, instance.PublicIPAddressGT(*i.PublicIPAddressGT))
	}
	if i.PublicIPAddressGTE != nil {
		predicates = append(predicates, instance.PublicIPAddressGTE(*i.PublicIPAddressGTE))
	}
	if i.PublicIPAddressLT != nil {
		predicates = append(predicates, instance.PublicIPAddressLT(*i.PublicIPAddressLT))
	}
	if i.PublicIPAddressLTE != nil {
		predicates = append(predicates, instance.PublicIPAddressLTE(*i.PublicIPAddressLTE))
	}
	if i.PublicIPAddressContains != nil {
		predicates = append(predicates, instance.PublicIPAddressContains(*i.PublicIPAddressContains))
	}
	if i.PublicIPAddressHasPrefix != nil {
		predicates = append(predicates, instance.PublicIPAddressHasPrefix(*i.PublicIPAddressHasPrefix))
	}
	if i.PublicIPAddressHasSuffix != nil {
		predicates = append(predicates, instance.PublicIPAddressHasSuffix(*i.PublicIPAddressHasSuffix))
	}
	if i.PublicIPAddressEqualFold != nil {
		predicates = append(predicates, instance.PublicIPAddressEqualFold(*i.PublicIPAddressEqualFold))
	}
	if i.PublicIPAddressContainsFold != nil {
		predicates = append(predicates, instance.PublicIPAddressContainsFold(*i.PublicIPAddressContainsFold))
	}
	if i.ImageID != nil {
		predicates = append(predicates, instance.ImageIDEQ(*i.ImageID))
	}
	if i.ImageIDNEQ != nil {
		predicates = append(predicates, instance.ImageIDNEQ(*i.ImageIDNEQ))
	}
	if len(i.ImageIDIn) > 0 {
		predicates = append(predicates, instance.ImageIDIn(i.ImageIDIn...))
	}
	if len(i.ImageIDNotIn) > 0 {
		predicates = append(predicates, instance.ImageIDNotIn(i.ImageIDNotIn...))
	}
	if i.ImageIDGT != nil {
		predicates = append(predicates, instance.ImageIDGT(*i.ImageIDGT))
	}
	if i.ImageIDGTE != nil {
		predicates = append(predicates, instance.ImageIDGTE(*i.ImageIDGTE))
	}
	if i.ImageIDLT != nil {
		predicates = append(predicates, instance.ImageIDLT(*i.ImageIDLT))
	}
	if i.ImageIDLTE != nil {
		predicates = append(predicates, instance.ImageIDLTE(*i.ImageIDLTE))
	}
	if i.ImageIDContains != nil {
		predicates = append(predicates, instance.ImageIDContains(*i.ImageIDContains))
	}
	if i.ImageIDHasPrefix != nil {
		predicates = append(predicates, instance.ImageIDHasPrefix(*i.ImageIDHasPrefix))
	}
	if i.ImageIDHasSuffix != nil {
		predicates = append(predicates, instance.ImageIDHasSuffix(*i.ImageIDHasSuffix))
	}
	if i.ImageIDEqualFold != nil {
		predicates = append(predicates, instance.ImageIDEqualFold(*i.ImageIDEqualFold))
	}
	if i.ImageIDContainsFold != nil {
		predicates = append(predicates, instance.ImageIDContainsFold(*i.ImageIDContainsFold))
	}
	if i.Architecture != nil {
		predicates = append(predicates, instance.ArchitectureEQ(*i.Architecture))
	}
	if i.ArchitectureNEQ != nil {
		predicates = append(predicates, instance.ArchitectureNEQ(*i.ArchitectureNEQ))
	}
	if len(i.ArchitectureIn) > 0 {
		predicates = append(predicates, instance.ArchitectureIn(i.ArchitectureIn...))
	}
	if len(i.ArchitectureNotIn) > 0 {
		predicates = append(predicates, instance.ArchitectureNotIn(i.ArchitectureNotIn...))
	}
	if i.ArchitectureGT != nil {
		predicates = append(predicates, instance.ArchitectureGT(*i.ArchitectureGT))
	}
	if i.ArchitectureGTE != nil {
		predicates = append(predicates, instance.ArchitectureGTE(*i.ArchitectureGTE))
	}
	if i.ArchitectureLT != nil {
		predicates = append(predicates, instance.ArchitectureLT(*i.ArchitectureLT))
	}
	if i.ArchitectureLTE != nil {
		predicates = append(predicates, instance.ArchitectureLTE(*i.ArchitectureLTE))
	}
	if i.ArchitectureContains != nil {
		predicates = append(predicates, instance.ArchitectureContains(*i.ArchitectureContains))
	}
	if i.ArchitectureHasPrefix != nil {
		predicates = append(predicates, instance.ArchitectureHasPrefix(*i.ArchitectureHasPrefix))
	}
	if i.ArchitectureHasSuffix != nil {
		predicates = append(predicates, instance.ArchitectureHasSuffix(*i.ArchitectureHasSuffix))
	}
	if i.ArchitectureEqualFold != nil {
		predicates = append(predicates, instance.ArchitectureEqualFold(*i.ArchitectureEqualFold))
	}
	if i.ArchitectureContainsFold != nil {
		predicates = append(predicates, instance.ArchitectureContainsFold(*i.ArchitectureContainsFold))
	}
	if i.AvailabilityZone != nil {
		predicates = append(predicates, instance.AvailabilityZoneEQ(*i.AvailabilityZone))
	}
	if i.AvailabilityZoneNEQ != nil {
		predicates = append(predicates, instance.AvailabilityZoneNEQ(*i.AvailabilityZoneNEQ))
	}
	if len(i.AvailabilityZoneIn) > 0 {
		predicates = append(predicates, instance.AvailabilityZoneIn(i.AvailabilityZoneIn...))
	}
	if len(i.AvailabilityZoneNotIn) > 0 {
		predicates = append(predicates, instance.AvailabilityZoneNotIn(i.AvailabilityZoneNotIn...))
	}
	if i.AvailabilityZoneGT != nil {
		predicates = append(predicates, instance.AvailabilityZoneGT(*i.AvailabilityZoneGT))
	}
	if i.AvailabilityZoneGTE != nil {
		predicates = append(predicates, instance.AvailabilityZoneGTE(*i.AvailabilityZoneGTE))
	}
	if i.AvailabilityZoneLT != nil {
		predicates = append(predicates, instance.AvailabilityZoneLT(*i.AvailabilityZoneLT))
	}
	if i.AvailabilityZoneLTE != nil {
		predicates = append(predicates, instance.AvailabilityZoneLTE(*i.AvailabilityZoneLTE))
	}
	if i.AvailabilityZoneContains != nil {
		predicates = append(predicates, instance.AvailabilityZoneContains(*i.AvailabilityZoneContains))
	}
	if i.AvailabilityZoneHasPrefix != nil {
		predicates = append(predicates, instance.AvailabilityZoneHasPrefix(*i.AvailabilityZoneHasPrefix))
	}
	if i.AvailabilityZoneHasSuffix != nil {
		predicates = append(predicates, instance.AvailabilityZoneHasSuffix(*i.AvailabilityZoneHasSuffix))
	}
	if i.AvailabilityZoneEqualFold != nil {
		predicates = append(predicates, instance.AvailabilityZoneEqualFold(*i.AvailabilityZoneEqualFold))
	}
	if i.AvailabilityZoneContainsFold != nil {
		predicates = append(predicates, instance.AvailabilityZoneContainsFold(*i.AvailabilityZoneContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, instance.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, instance.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, instance.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, instance.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, instance.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, instance.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, instance.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, instance.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, instance.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, instance.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, instance.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, instance.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, instance.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, instance.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, instance.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, instance.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasUser != nil {
		p := instance.HasUser()
		if !*i.HasUser {
			p = instance.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, instance.HasUserWith(with...))
	}
	if i.HasSlide != nil {
		p := instance.HasSlide()
		if !*i.HasSlide {
			p = instance.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSlideWith) > 0 {
		with := make([]predicate.Slide, 0, len(i.HasSlideWith))
		for _, w := range i.HasSlideWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, instance.HasSlideWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/marcustut/fyp/backend/ent: empty predicate InstanceWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return instance.And(predicates...), nil
	}
}

// LinkWhereInput represents a where input for filtering Link queries.
type LinkWhereInput struct {
	Not *LinkWhereInput   `json:"not,omitempty"`
	Or  []*LinkWhereInput `json:"or,omitempty"`
	And []*LinkWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *ulid.ID  `json:"id,omitempty"`
	IDNEQ   *ulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []ulid.ID `json:"idIn,omitempty"`
	IDNotIn []ulid.ID `json:"idNotIn,omitempty"`
	IDGT    *ulid.ID  `json:"idGT,omitempty"`
	IDGTE   *ulid.ID  `json:"idGTE,omitempty"`
	IDLT    *ulid.ID  `json:"idLT,omitempty"`
	IDLTE   *ulid.ID  `json:"idLTE,omitempty"`

	// "link_id" field predicates.
	LinkID             *string  `json:"linkID,omitempty"`
	LinkIDNEQ          *string  `json:"linkIDNEQ,omitempty"`
	LinkIDIn           []string `json:"linkIDIn,omitempty"`
	LinkIDNotIn        []string `json:"linkIDNotIn,omitempty"`
	LinkIDGT           *string  `json:"linkIDGT,omitempty"`
	LinkIDGTE          *string  `json:"linkIDGTE,omitempty"`
	LinkIDLT           *string  `json:"linkIDLT,omitempty"`
	LinkIDLTE          *string  `json:"linkIDLTE,omitempty"`
	LinkIDContains     *string  `json:"linkIDContains,omitempty"`
	LinkIDHasPrefix    *string  `json:"linkIDHasPrefix,omitempty"`
	LinkIDHasSuffix    *string  `json:"linkIDHasSuffix,omitempty"`
	LinkIDEqualFold    *string  `json:"linkIDEqualFold,omitempty"`
	LinkIDContainsFold *string  `json:"linkIDContainsFold,omitempty"`

	// "original_url" field predicates.
	OriginalURL             *string  `json:"originalURL,omitempty"`
	OriginalURLNEQ          *string  `json:"originalURLNEQ,omitempty"`
	OriginalURLIn           []string `json:"originalURLIn,omitempty"`
	OriginalURLNotIn        []string `json:"originalURLNotIn,omitempty"`
	OriginalURLGT           *string  `json:"originalURLGT,omitempty"`
	OriginalURLGTE          *string  `json:"originalURLGTE,omitempty"`
	OriginalURLLT           *string  `json:"originalURLLT,omitempty"`
	OriginalURLLTE          *string  `json:"originalURLLTE,omitempty"`
	OriginalURLContains     *string  `json:"originalURLContains,omitempty"`
	OriginalURLHasPrefix    *string  `json:"originalURLHasPrefix,omitempty"`
	OriginalURLHasSuffix    *string  `json:"originalURLHasSuffix,omitempty"`
	OriginalURLEqualFold    *string  `json:"originalURLEqualFold,omitempty"`
	OriginalURLContainsFold *string  `json:"originalURLContainsFold,omitempty"`

	// "visited_count" field predicates.
	VisitedCount      *int64  `json:"visitedCount,omitempty"`
	VisitedCountNEQ   *int64  `json:"visitedCountNEQ,omitempty"`
	VisitedCountIn    []int64 `json:"visitedCountIn,omitempty"`
	VisitedCountNotIn []int64 `json:"visitedCountNotIn,omitempty"`
	VisitedCountGT    *int64  `json:"visitedCountGT,omitempty"`
	VisitedCountGTE   *int64  `json:"visitedCountGTE,omitempty"`
	VisitedCountLT    *int64  `json:"visitedCountLT,omitempty"`
	VisitedCountLTE   *int64  `json:"visitedCountLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`
}

// Filter applies the LinkWhereInput filter on the LinkQuery builder.
func (i *LinkWhereInput) Filter(q *LinkQuery) (*LinkQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering links.
// An error is returned if the input is empty or invalid.
func (i *LinkWhereInput) P() (predicate.Link, error) {
	var predicates []predicate.Link
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, link.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Link, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, link.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Link, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, link.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, link.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, link.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, link.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, link.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, link.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, link.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, link.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, link.IDLTE(*i.IDLTE))
	}
	if i.LinkID != nil {
		predicates = append(predicates, link.LinkIDEQ(*i.LinkID))
	}
	if i.LinkIDNEQ != nil {
		predicates = append(predicates, link.LinkIDNEQ(*i.LinkIDNEQ))
	}
	if len(i.LinkIDIn) > 0 {
		predicates = append(predicates, link.LinkIDIn(i.LinkIDIn...))
	}
	if len(i.LinkIDNotIn) > 0 {
		predicates = append(predicates, link.LinkIDNotIn(i.LinkIDNotIn...))
	}
	if i.LinkIDGT != nil {
		predicates = append(predicates, link.LinkIDGT(*i.LinkIDGT))
	}
	if i.LinkIDGTE != nil {
		predicates = append(predicates, link.LinkIDGTE(*i.LinkIDGTE))
	}
	if i.LinkIDLT != nil {
		predicates = append(predicates, link.LinkIDLT(*i.LinkIDLT))
	}
	if i.LinkIDLTE != nil {
		predicates = append(predicates, link.LinkIDLTE(*i.LinkIDLTE))
	}
	if i.LinkIDContains != nil {
		predicates = append(predicates, link.LinkIDContains(*i.LinkIDContains))
	}
	if i.LinkIDHasPrefix != nil {
		predicates = append(predicates, link.LinkIDHasPrefix(*i.LinkIDHasPrefix))
	}
	if i.LinkIDHasSuffix != nil {
		predicates = append(predicates, link.LinkIDHasSuffix(*i.LinkIDHasSuffix))
	}
	if i.LinkIDEqualFold != nil {
		predicates = append(predicates, link.LinkIDEqualFold(*i.LinkIDEqualFold))
	}
	if i.LinkIDContainsFold != nil {
		predicates = append(predicates, link.LinkIDContainsFold(*i.LinkIDContainsFold))
	}
	if i.OriginalURL != nil {
		predicates = append(predicates, link.OriginalURLEQ(*i.OriginalURL))
	}
	if i.OriginalURLNEQ != nil {
		predicates = append(predicates, link.OriginalURLNEQ(*i.OriginalURLNEQ))
	}
	if len(i.OriginalURLIn) > 0 {
		predicates = append(predicates, link.OriginalURLIn(i.OriginalURLIn...))
	}
	if len(i.OriginalURLNotIn) > 0 {
		predicates = append(predicates, link.OriginalURLNotIn(i.OriginalURLNotIn...))
	}
	if i.OriginalURLGT != nil {
		predicates = append(predicates, link.OriginalURLGT(*i.OriginalURLGT))
	}
	if i.OriginalURLGTE != nil {
		predicates = append(predicates, link.OriginalURLGTE(*i.OriginalURLGTE))
	}
	if i.OriginalURLLT != nil {
		predicates = append(predicates, link.OriginalURLLT(*i.OriginalURLLT))
	}
	if i.OriginalURLLTE != nil {
		predicates = append(predicates, link.OriginalURLLTE(*i.OriginalURLLTE))
	}
	if i.OriginalURLContains != nil {
		predicates = append(predicates, link.OriginalURLContains(*i.OriginalURLContains))
	}
	if i.OriginalURLHasPrefix != nil {
		predicates = append(predicates, link.OriginalURLHasPrefix(*i.OriginalURLHasPrefix))
	}
	if i.OriginalURLHasSuffix != nil {
		predicates = append(predicates, link.OriginalURLHasSuffix(*i.OriginalURLHasSuffix))
	}
	if i.OriginalURLEqualFold != nil {
		predicates = append(predicates, link.OriginalURLEqualFold(*i.OriginalURLEqualFold))
	}
	if i.OriginalURLContainsFold != nil {
		predicates = append(predicates, link.OriginalURLContainsFold(*i.OriginalURLContainsFold))
	}
	if i.VisitedCount != nil {
		predicates = append(predicates, link.VisitedCountEQ(*i.VisitedCount))
	}
	if i.VisitedCountNEQ != nil {
		predicates = append(predicates, link.VisitedCountNEQ(*i.VisitedCountNEQ))
	}
	if len(i.VisitedCountIn) > 0 {
		predicates = append(predicates, link.VisitedCountIn(i.VisitedCountIn...))
	}
	if len(i.VisitedCountNotIn) > 0 {
		predicates = append(predicates, link.VisitedCountNotIn(i.VisitedCountNotIn...))
	}
	if i.VisitedCountGT != nil {
		predicates = append(predicates, link.VisitedCountGT(*i.VisitedCountGT))
	}
	if i.VisitedCountGTE != nil {
		predicates = append(predicates, link.VisitedCountGTE(*i.VisitedCountGTE))
	}
	if i.VisitedCountLT != nil {
		predicates = append(predicates, link.VisitedCountLT(*i.VisitedCountLT))
	}
	if i.VisitedCountLTE != nil {
		predicates = append(predicates, link.VisitedCountLTE(*i.VisitedCountLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, link.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, link.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, link.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, link.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, link.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, link.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, link.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, link.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, link.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, link.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, link.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, link.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, link.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, link.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, link.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, link.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasOwner != nil {
		p := link.HasOwner()
		if !*i.HasOwner {
			p = link.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, link.HasOwnerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/marcustut/fyp/backend/ent: empty predicate LinkWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return link.And(predicates...), nil
	}
}

// SlideWhereInput represents a where input for filtering Slide queries.
type SlideWhereInput struct {
	Not *SlideWhereInput   `json:"not,omitempty"`
	Or  []*SlideWhereInput `json:"or,omitempty"`
	And []*SlideWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *ulid.ID  `json:"id,omitempty"`
	IDNEQ   *ulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []ulid.ID `json:"idIn,omitempty"`
	IDNotIn []ulid.ID `json:"idNotIn,omitempty"`
	IDGT    *ulid.ID  `json:"idGT,omitempty"`
	IDGTE   *ulid.ID  `json:"idGTE,omitempty"`
	IDLT    *ulid.ID  `json:"idLT,omitempty"`
	IDLTE   *ulid.ID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "size" field predicates.
	Size       *int64  `json:"size,omitempty"`
	SizeNEQ    *int64  `json:"sizeNEQ,omitempty"`
	SizeIn     []int64 `json:"sizeIn,omitempty"`
	SizeNotIn  []int64 `json:"sizeNotIn,omitempty"`
	SizeGT     *int64  `json:"sizeGT,omitempty"`
	SizeGTE    *int64  `json:"sizeGTE,omitempty"`
	SizeLT     *int64  `json:"sizeLT,omitempty"`
	SizeLTE    *int64  `json:"sizeLTE,omitempty"`
	SizeIsNil  bool    `json:"sizeIsNil,omitempty"`
	SizeNotNil bool    `json:"sizeNotNil,omitempty"`

	// "access_level" field predicates.
	AccessLevel      *slide.AccessLevel  `json:"accessLevel,omitempty"`
	AccessLevelNEQ   *slide.AccessLevel  `json:"accessLevelNEQ,omitempty"`
	AccessLevelIn    []slide.AccessLevel `json:"accessLevelIn,omitempty"`
	AccessLevelNotIn []slide.AccessLevel `json:"accessLevelNotIn,omitempty"`

	// "deleted" field predicates.
	Deleted    *bool `json:"deleted,omitempty"`
	DeletedNEQ *bool `json:"deletedNEQ,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "instance" edge predicates.
	HasInstance     *bool                 `json:"hasInstance,omitempty"`
	HasInstanceWith []*InstanceWhereInput `json:"hasInstanceWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// Filter applies the SlideWhereInput filter on the SlideQuery builder.
func (i *SlideWhereInput) Filter(q *SlideQuery) (*SlideQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering slides.
// An error is returned if the input is empty or invalid.
func (i *SlideWhereInput) P() (predicate.Slide, error) {
	var predicates []predicate.Slide
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, slide.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Slide, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, slide.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Slide, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, slide.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, slide.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, slide.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, slide.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, slide.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, slide.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, slide.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, slide.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, slide.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, slide.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, slide.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, slide.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, slide.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, slide.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, slide.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, slide.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, slide.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, slide.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, slide.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, slide.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, slide.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, slide.NameContainsFold(*i.NameContainsFold))
	}
	if i.Size != nil {
		predicates = append(predicates, slide.SizeEQ(*i.Size))
	}
	if i.SizeNEQ != nil {
		predicates = append(predicates, slide.SizeNEQ(*i.SizeNEQ))
	}
	if len(i.SizeIn) > 0 {
		predicates = append(predicates, slide.SizeIn(i.SizeIn...))
	}
	if len(i.SizeNotIn) > 0 {
		predicates = append(predicates, slide.SizeNotIn(i.SizeNotIn...))
	}
	if i.SizeGT != nil {
		predicates = append(predicates, slide.SizeGT(*i.SizeGT))
	}
	if i.SizeGTE != nil {
		predicates = append(predicates, slide.SizeGTE(*i.SizeGTE))
	}
	if i.SizeLT != nil {
		predicates = append(predicates, slide.SizeLT(*i.SizeLT))
	}
	if i.SizeLTE != nil {
		predicates = append(predicates, slide.SizeLTE(*i.SizeLTE))
	}
	if i.SizeIsNil {
		predicates = append(predicates, slide.SizeIsNil())
	}
	if i.SizeNotNil {
		predicates = append(predicates, slide.SizeNotNil())
	}
	if i.AccessLevel != nil {
		predicates = append(predicates, slide.AccessLevelEQ(*i.AccessLevel))
	}
	if i.AccessLevelNEQ != nil {
		predicates = append(predicates, slide.AccessLevelNEQ(*i.AccessLevelNEQ))
	}
	if len(i.AccessLevelIn) > 0 {
		predicates = append(predicates, slide.AccessLevelIn(i.AccessLevelIn...))
	}
	if len(i.AccessLevelNotIn) > 0 {
		predicates = append(predicates, slide.AccessLevelNotIn(i.AccessLevelNotIn...))
	}
	if i.Deleted != nil {
		predicates = append(predicates, slide.DeletedEQ(*i.Deleted))
	}
	if i.DeletedNEQ != nil {
		predicates = append(predicates, slide.DeletedNEQ(*i.DeletedNEQ))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, slide.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, slide.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, slide.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, slide.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, slide.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, slide.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, slide.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, slide.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, slide.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, slide.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, slide.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, slide.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, slide.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, slide.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, slide.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, slide.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasInstance != nil {
		p := slide.HasInstance()
		if !*i.HasInstance {
			p = slide.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInstanceWith) > 0 {
		with := make([]predicate.Instance, 0, len(i.HasInstanceWith))
		for _, w := range i.HasInstanceWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, slide.HasInstanceWith(with...))
	}
	if i.HasUser != nil {
		p := slide.HasUser()
		if !*i.HasUser {
			p = slide.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, slide.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/marcustut/fyp/backend/ent: empty predicate SlideWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return slide.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Not *UserWhereInput   `json:"not,omitempty"`
	Or  []*UserWhereInput `json:"or,omitempty"`
	And []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *ulid.ID  `json:"id,omitempty"`
	IDNEQ   *ulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []ulid.ID `json:"idIn,omitempty"`
	IDNotIn []ulid.ID `json:"idNotIn,omitempty"`
	IDGT    *ulid.ID  `json:"idGT,omitempty"`
	IDGTE   *ulid.ID  `json:"idGTE,omitempty"`
	IDLT    *ulid.ID  `json:"idLT,omitempty"`
	IDLTE   *ulid.ID  `json:"idLTE,omitempty"`

	// "username" field predicates.
	Username             *string  `json:"username,omitempty"`
	UsernameNEQ          *string  `json:"usernameNEQ,omitempty"`
	UsernameIn           []string `json:"usernameIn,omitempty"`
	UsernameNotIn        []string `json:"usernameNotIn,omitempty"`
	UsernameGT           *string  `json:"usernameGT,omitempty"`
	UsernameGTE          *string  `json:"usernameGTE,omitempty"`
	UsernameLT           *string  `json:"usernameLT,omitempty"`
	UsernameLTE          *string  `json:"usernameLTE,omitempty"`
	UsernameContains     *string  `json:"usernameContains,omitempty"`
	UsernameHasPrefix    *string  `json:"usernameHasPrefix,omitempty"`
	UsernameHasSuffix    *string  `json:"usernameHasSuffix,omitempty"`
	UsernameEqualFold    *string  `json:"usernameEqualFold,omitempty"`
	UsernameContainsFold *string  `json:"usernameContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "full_name" field predicates.
	FullName             *string  `json:"fullName,omitempty"`
	FullNameNEQ          *string  `json:"fullNameNEQ,omitempty"`
	FullNameIn           []string `json:"fullNameIn,omitempty"`
	FullNameNotIn        []string `json:"fullNameNotIn,omitempty"`
	FullNameGT           *string  `json:"fullNameGT,omitempty"`
	FullNameGTE          *string  `json:"fullNameGTE,omitempty"`
	FullNameLT           *string  `json:"fullNameLT,omitempty"`
	FullNameLTE          *string  `json:"fullNameLTE,omitempty"`
	FullNameContains     *string  `json:"fullNameContains,omitempty"`
	FullNameHasPrefix    *string  `json:"fullNameHasPrefix,omitempty"`
	FullNameHasSuffix    *string  `json:"fullNameHasSuffix,omitempty"`
	FullNameIsNil        bool     `json:"fullNameIsNil,omitempty"`
	FullNameNotNil       bool     `json:"fullNameNotNil,omitempty"`
	FullNameEqualFold    *string  `json:"fullNameEqualFold,omitempty"`
	FullNameContainsFold *string  `json:"fullNameContainsFold,omitempty"`

	// "password_hash" field predicates.
	PasswordHash             *string  `json:"passwordHash,omitempty"`
	PasswordHashNEQ          *string  `json:"passwordHashNEQ,omitempty"`
	PasswordHashIn           []string `json:"passwordHashIn,omitempty"`
	PasswordHashNotIn        []string `json:"passwordHashNotIn,omitempty"`
	PasswordHashGT           *string  `json:"passwordHashGT,omitempty"`
	PasswordHashGTE          *string  `json:"passwordHashGTE,omitempty"`
	PasswordHashLT           *string  `json:"passwordHashLT,omitempty"`
	PasswordHashLTE          *string  `json:"passwordHashLTE,omitempty"`
	PasswordHashContains     *string  `json:"passwordHashContains,omitempty"`
	PasswordHashHasPrefix    *string  `json:"passwordHashHasPrefix,omitempty"`
	PasswordHashHasSuffix    *string  `json:"passwordHashHasSuffix,omitempty"`
	PasswordHashEqualFold    *string  `json:"passwordHashEqualFold,omitempty"`
	PasswordHashContainsFold *string  `json:"passwordHashContainsFold,omitempty"`

	// "avatar_url" field predicates.
	AvatarURL             *string  `json:"avatarURL,omitempty"`
	AvatarURLNEQ          *string  `json:"avatarURLNEQ,omitempty"`
	AvatarURLIn           []string `json:"avatarURLIn,omitempty"`
	AvatarURLNotIn        []string `json:"avatarURLNotIn,omitempty"`
	AvatarURLGT           *string  `json:"avatarURLGT,omitempty"`
	AvatarURLGTE          *string  `json:"avatarURLGTE,omitempty"`
	AvatarURLLT           *string  `json:"avatarURLLT,omitempty"`
	AvatarURLLTE          *string  `json:"avatarURLLTE,omitempty"`
	AvatarURLContains     *string  `json:"avatarURLContains,omitempty"`
	AvatarURLHasPrefix    *string  `json:"avatarURLHasPrefix,omitempty"`
	AvatarURLHasSuffix    *string  `json:"avatarURLHasSuffix,omitempty"`
	AvatarURLIsNil        bool     `json:"avatarURLIsNil,omitempty"`
	AvatarURLNotNil       bool     `json:"avatarURLNotNil,omitempty"`
	AvatarURLEqualFold    *string  `json:"avatarURLEqualFold,omitempty"`
	AvatarURLContainsFold *string  `json:"avatarURLContainsFold,omitempty"`

	// "bio" field predicates.
	Bio             *string  `json:"bio,omitempty"`
	BioNEQ          *string  `json:"bioNEQ,omitempty"`
	BioIn           []string `json:"bioIn,omitempty"`
	BioNotIn        []string `json:"bioNotIn,omitempty"`
	BioGT           *string  `json:"bioGT,omitempty"`
	BioGTE          *string  `json:"bioGTE,omitempty"`
	BioLT           *string  `json:"bioLT,omitempty"`
	BioLTE          *string  `json:"bioLTE,omitempty"`
	BioContains     *string  `json:"bioContains,omitempty"`
	BioHasPrefix    *string  `json:"bioHasPrefix,omitempty"`
	BioHasSuffix    *string  `json:"bioHasSuffix,omitempty"`
	BioIsNil        bool     `json:"bioIsNil,omitempty"`
	BioNotNil       bool     `json:"bioNotNil,omitempty"`
	BioEqualFold    *string  `json:"bioEqualFold,omitempty"`
	BioContainsFold *string  `json:"bioContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "instances" edge predicates.
	HasInstances     *bool                 `json:"hasInstances,omitempty"`
	HasInstancesWith []*InstanceWhereInput `json:"hasInstancesWith,omitempty"`

	// "slides" edge predicates.
	HasSlides     *bool              `json:"hasSlides,omitempty"`
	HasSlidesWith []*SlideWhereInput `json:"hasSlidesWith,omitempty"`

	// "links" edge predicates.
	HasLinks     *bool             `json:"hasLinks,omitempty"`
	HasLinksWith []*LinkWhereInput `json:"hasLinksWith,omitempty"`
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.Username != nil {
		predicates = append(predicates, user.UsernameEQ(*i.Username))
	}
	if i.UsernameNEQ != nil {
		predicates = append(predicates, user.UsernameNEQ(*i.UsernameNEQ))
	}
	if len(i.UsernameIn) > 0 {
		predicates = append(predicates, user.UsernameIn(i.UsernameIn...))
	}
	if len(i.UsernameNotIn) > 0 {
		predicates = append(predicates, user.UsernameNotIn(i.UsernameNotIn...))
	}
	if i.UsernameGT != nil {
		predicates = append(predicates, user.UsernameGT(*i.UsernameGT))
	}
	if i.UsernameGTE != nil {
		predicates = append(predicates, user.UsernameGTE(*i.UsernameGTE))
	}
	if i.UsernameLT != nil {
		predicates = append(predicates, user.UsernameLT(*i.UsernameLT))
	}
	if i.UsernameLTE != nil {
		predicates = append(predicates, user.UsernameLTE(*i.UsernameLTE))
	}
	if i.UsernameContains != nil {
		predicates = append(predicates, user.UsernameContains(*i.UsernameContains))
	}
	if i.UsernameHasPrefix != nil {
		predicates = append(predicates, user.UsernameHasPrefix(*i.UsernameHasPrefix))
	}
	if i.UsernameHasSuffix != nil {
		predicates = append(predicates, user.UsernameHasSuffix(*i.UsernameHasSuffix))
	}
	if i.UsernameEqualFold != nil {
		predicates = append(predicates, user.UsernameEqualFold(*i.UsernameEqualFold))
	}
	if i.UsernameContainsFold != nil {
		predicates = append(predicates, user.UsernameContainsFold(*i.UsernameContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.FullName != nil {
		predicates = append(predicates, user.FullNameEQ(*i.FullName))
	}
	if i.FullNameNEQ != nil {
		predicates = append(predicates, user.FullNameNEQ(*i.FullNameNEQ))
	}
	if len(i.FullNameIn) > 0 {
		predicates = append(predicates, user.FullNameIn(i.FullNameIn...))
	}
	if len(i.FullNameNotIn) > 0 {
		predicates = append(predicates, user.FullNameNotIn(i.FullNameNotIn...))
	}
	if i.FullNameGT != nil {
		predicates = append(predicates, user.FullNameGT(*i.FullNameGT))
	}
	if i.FullNameGTE != nil {
		predicates = append(predicates, user.FullNameGTE(*i.FullNameGTE))
	}
	if i.FullNameLT != nil {
		predicates = append(predicates, user.FullNameLT(*i.FullNameLT))
	}
	if i.FullNameLTE != nil {
		predicates = append(predicates, user.FullNameLTE(*i.FullNameLTE))
	}
	if i.FullNameContains != nil {
		predicates = append(predicates, user.FullNameContains(*i.FullNameContains))
	}
	if i.FullNameHasPrefix != nil {
		predicates = append(predicates, user.FullNameHasPrefix(*i.FullNameHasPrefix))
	}
	if i.FullNameHasSuffix != nil {
		predicates = append(predicates, user.FullNameHasSuffix(*i.FullNameHasSuffix))
	}
	if i.FullNameIsNil {
		predicates = append(predicates, user.FullNameIsNil())
	}
	if i.FullNameNotNil {
		predicates = append(predicates, user.FullNameNotNil())
	}
	if i.FullNameEqualFold != nil {
		predicates = append(predicates, user.FullNameEqualFold(*i.FullNameEqualFold))
	}
	if i.FullNameContainsFold != nil {
		predicates = append(predicates, user.FullNameContainsFold(*i.FullNameContainsFold))
	}
	if i.PasswordHash != nil {
		predicates = append(predicates, user.PasswordHashEQ(*i.PasswordHash))
	}
	if i.PasswordHashNEQ != nil {
		predicates = append(predicates, user.PasswordHashNEQ(*i.PasswordHashNEQ))
	}
	if len(i.PasswordHashIn) > 0 {
		predicates = append(predicates, user.PasswordHashIn(i.PasswordHashIn...))
	}
	if len(i.PasswordHashNotIn) > 0 {
		predicates = append(predicates, user.PasswordHashNotIn(i.PasswordHashNotIn...))
	}
	if i.PasswordHashGT != nil {
		predicates = append(predicates, user.PasswordHashGT(*i.PasswordHashGT))
	}
	if i.PasswordHashGTE != nil {
		predicates = append(predicates, user.PasswordHashGTE(*i.PasswordHashGTE))
	}
	if i.PasswordHashLT != nil {
		predicates = append(predicates, user.PasswordHashLT(*i.PasswordHashLT))
	}
	if i.PasswordHashLTE != nil {
		predicates = append(predicates, user.PasswordHashLTE(*i.PasswordHashLTE))
	}
	if i.PasswordHashContains != nil {
		predicates = append(predicates, user.PasswordHashContains(*i.PasswordHashContains))
	}
	if i.PasswordHashHasPrefix != nil {
		predicates = append(predicates, user.PasswordHashHasPrefix(*i.PasswordHashHasPrefix))
	}
	if i.PasswordHashHasSuffix != nil {
		predicates = append(predicates, user.PasswordHashHasSuffix(*i.PasswordHashHasSuffix))
	}
	if i.PasswordHashEqualFold != nil {
		predicates = append(predicates, user.PasswordHashEqualFold(*i.PasswordHashEqualFold))
	}
	if i.PasswordHashContainsFold != nil {
		predicates = append(predicates, user.PasswordHashContainsFold(*i.PasswordHashContainsFold))
	}
	if i.AvatarURL != nil {
		predicates = append(predicates, user.AvatarURLEQ(*i.AvatarURL))
	}
	if i.AvatarURLNEQ != nil {
		predicates = append(predicates, user.AvatarURLNEQ(*i.AvatarURLNEQ))
	}
	if len(i.AvatarURLIn) > 0 {
		predicates = append(predicates, user.AvatarURLIn(i.AvatarURLIn...))
	}
	if len(i.AvatarURLNotIn) > 0 {
		predicates = append(predicates, user.AvatarURLNotIn(i.AvatarURLNotIn...))
	}
	if i.AvatarURLGT != nil {
		predicates = append(predicates, user.AvatarURLGT(*i.AvatarURLGT))
	}
	if i.AvatarURLGTE != nil {
		predicates = append(predicates, user.AvatarURLGTE(*i.AvatarURLGTE))
	}
	if i.AvatarURLLT != nil {
		predicates = append(predicates, user.AvatarURLLT(*i.AvatarURLLT))
	}
	if i.AvatarURLLTE != nil {
		predicates = append(predicates, user.AvatarURLLTE(*i.AvatarURLLTE))
	}
	if i.AvatarURLContains != nil {
		predicates = append(predicates, user.AvatarURLContains(*i.AvatarURLContains))
	}
	if i.AvatarURLHasPrefix != nil {
		predicates = append(predicates, user.AvatarURLHasPrefix(*i.AvatarURLHasPrefix))
	}
	if i.AvatarURLHasSuffix != nil {
		predicates = append(predicates, user.AvatarURLHasSuffix(*i.AvatarURLHasSuffix))
	}
	if i.AvatarURLIsNil {
		predicates = append(predicates, user.AvatarURLIsNil())
	}
	if i.AvatarURLNotNil {
		predicates = append(predicates, user.AvatarURLNotNil())
	}
	if i.AvatarURLEqualFold != nil {
		predicates = append(predicates, user.AvatarURLEqualFold(*i.AvatarURLEqualFold))
	}
	if i.AvatarURLContainsFold != nil {
		predicates = append(predicates, user.AvatarURLContainsFold(*i.AvatarURLContainsFold))
	}
	if i.Bio != nil {
		predicates = append(predicates, user.BioEQ(*i.Bio))
	}
	if i.BioNEQ != nil {
		predicates = append(predicates, user.BioNEQ(*i.BioNEQ))
	}
	if len(i.BioIn) > 0 {
		predicates = append(predicates, user.BioIn(i.BioIn...))
	}
	if len(i.BioNotIn) > 0 {
		predicates = append(predicates, user.BioNotIn(i.BioNotIn...))
	}
	if i.BioGT != nil {
		predicates = append(predicates, user.BioGT(*i.BioGT))
	}
	if i.BioGTE != nil {
		predicates = append(predicates, user.BioGTE(*i.BioGTE))
	}
	if i.BioLT != nil {
		predicates = append(predicates, user.BioLT(*i.BioLT))
	}
	if i.BioLTE != nil {
		predicates = append(predicates, user.BioLTE(*i.BioLTE))
	}
	if i.BioContains != nil {
		predicates = append(predicates, user.BioContains(*i.BioContains))
	}
	if i.BioHasPrefix != nil {
		predicates = append(predicates, user.BioHasPrefix(*i.BioHasPrefix))
	}
	if i.BioHasSuffix != nil {
		predicates = append(predicates, user.BioHasSuffix(*i.BioHasSuffix))
	}
	if i.BioIsNil {
		predicates = append(predicates, user.BioIsNil())
	}
	if i.BioNotNil {
		predicates = append(predicates, user.BioNotNil())
	}
	if i.BioEqualFold != nil {
		predicates = append(predicates, user.BioEqualFold(*i.BioEqualFold))
	}
	if i.BioContainsFold != nil {
		predicates = append(predicates, user.BioContainsFold(*i.BioContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, user.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, user.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, user.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, user.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, user.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, user.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, user.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, user.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasInstances != nil {
		p := user.HasInstances()
		if !*i.HasInstances {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInstancesWith) > 0 {
		with := make([]predicate.Instance, 0, len(i.HasInstancesWith))
		for _, w := range i.HasInstancesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasInstancesWith(with...))
	}
	if i.HasSlides != nil {
		p := user.HasSlides()
		if !*i.HasSlides {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSlidesWith) > 0 {
		with := make([]predicate.Slide, 0, len(i.HasSlidesWith))
		for _, w := range i.HasSlidesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasSlidesWith(with...))
	}
	if i.HasLinks != nil {
		p := user.HasLinks()
		if !*i.HasLinks {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLinksWith) > 0 {
		with := make([]predicate.Link, 0, len(i.HasLinksWith))
		for _, w := range i.HasLinksWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasLinksWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/marcustut/fyp/backend/ent: empty predicate UserWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}
