import gql from 'graphql-tag';
import * as Urql from 'urql';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  Cursor: any;
  Metadata: any;
  Time: any;
};

export type CreateSlideInput = {
  name?: InputMaybe<Scalars['String']>;
};

export type CreateUserInput = {
  avatar_url?: InputMaybe<Scalars['String']>;
  bio?: InputMaybe<Scalars['String']>;
  email: Scalars['String'];
  full_name?: InputMaybe<Scalars['String']>;
  password: Scalars['String'];
  username: Scalars['String'];
};

export type Mutation = {
  __typename?: 'Mutation';
  CreateSlide: Slide;
  CreateUser: User;
  DeleteUser: User;
  DeleteUserByEmail: User;
  DeleteUserByUsername: User;
  SignInWithEmail: UserWithAuth;
  SignInWithGithub: UserWithAuth;
  SignInWithUsername: UserWithAuth;
  SignUp: UserWithAuth;
  UpdateSlide: Slide;
  UpdateUser: User;
};


export type MutationCreateSlideArgs = {
  input: CreateSlideInput;
};


export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


export type MutationDeleteUserArgs = {
  id: Scalars['ID'];
};


export type MutationDeleteUserByEmailArgs = {
  email: Scalars['String'];
};


export type MutationDeleteUserByUsernameArgs = {
  username: Scalars['String'];
};


export type MutationSignInWithEmailArgs = {
  input: SignInWithEmail;
};


export type MutationSignInWithGithubArgs = {
  token: Scalars['String'];
};


export type MutationSignInWithUsernameArgs = {
  input: SignInWithUsername;
};


export type MutationSignUpArgs = {
  input: CreateUserInput;
};


export type MutationUpdateSlideArgs = {
  input: UpdateSlideInput;
};


export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};

export type Node = {
  id: Scalars['ID'];
};

export enum OrderDirection {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type PageInfo = {
  __typename?: 'PageInfo';
  endCursor?: Maybe<Scalars['Cursor']>;
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
  startCursor?: Maybe<Scalars['Cursor']>;
};

export type Query = {
  __typename?: 'Query';
  Node?: Maybe<Node>;
  Slide: Slide;
  Slides: SlideConnection;
  User: User;
  UserByAccessToken: UserWithAuth;
  UserByEmail: User;
  UserByUsername: User;
  Users: UserConnection;
  ValidateAccessToken: Scalars['Boolean'];
};


export type QueryNodeArgs = {
  id: Scalars['ID'];
};


export type QuerySlideArgs = {
  id: Scalars['ID'];
};


export type QuerySlidesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SlideOrder>;
  where?: InputMaybe<SlideWhereInput>;
};


export type QueryUserArgs = {
  id: Scalars['ID'];
};


export type QueryUserByAccessTokenArgs = {
  token: Scalars['String'];
};


export type QueryUserByEmailArgs = {
  email: Scalars['String'];
};


export type QueryUserByUsernameArgs = {
  username: Scalars['String'];
};


export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<UserOrder>;
  where?: InputMaybe<UserWhereInput>;
};


export type QueryValidateAccessTokenArgs = {
  token: Scalars['String'];
};

export type SignInWithEmail = {
  email: Scalars['String'];
  password: Scalars['String'];
};

export type SignInWithUsername = {
  password: Scalars['String'];
  username: Scalars['String'];
};

export type Slide = {
  __typename?: 'Slide';
  created_at: Scalars['Time'];
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  updated_at: Scalars['Time'];
};

export type SlideConnection = {
  __typename?: 'SlideConnection';
  edges?: Maybe<Array<Maybe<SlideEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type SlideEdge = {
  __typename?: 'SlideEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<Slide>;
};

export type SlideOrder = {
  direction: OrderDirection;
  field?: InputMaybe<SlideOrderField>;
};

export enum SlideOrderField {
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * SlideWhereInput is used for filtering Slide objects.
 * Input was generated by ent.
 */
export type SlideWhereInput = {
  and?: InputMaybe<Array<SlideWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<SlideWhereInput>;
  or?: InputMaybe<Array<SlideWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export type UpdateSlideInput = {
  id: Scalars['ID'];
  name?: InputMaybe<Scalars['String']>;
};

export type UpdateUserInput = {
  avatar_url?: InputMaybe<Scalars['String']>;
  bio?: InputMaybe<Scalars['String']>;
  clear_avatar_url?: InputMaybe<Scalars['Boolean']>;
  clear_bio?: InputMaybe<Scalars['Boolean']>;
  full_name?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  username?: InputMaybe<Scalars['String']>;
};

export type User = {
  __typename?: 'User';
  avatar_url?: Maybe<Scalars['String']>;
  bio?: Maybe<Scalars['String']>;
  created_at: Scalars['Time'];
  email: Scalars['String'];
  full_name?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  updated_at: Scalars['Time'];
  username: Scalars['String'];
};

export type UserConnection = {
  __typename?: 'UserConnection';
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type UserEdge = {
  __typename?: 'UserEdge';
  cursor: Scalars['Cursor'];
  node?: Maybe<User>;
};

export type UserOrder = {
  direction: OrderDirection;
  field?: InputMaybe<UserOrderField>;
};

export enum UserOrderField {
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  and?: InputMaybe<Array<UserWhereInput>>;
  /** avatar_url field predicates */
  avatarURL?: InputMaybe<Scalars['String']>;
  avatarURLContains?: InputMaybe<Scalars['String']>;
  avatarURLContainsFold?: InputMaybe<Scalars['String']>;
  avatarURLEqualFold?: InputMaybe<Scalars['String']>;
  avatarURLGT?: InputMaybe<Scalars['String']>;
  avatarURLGTE?: InputMaybe<Scalars['String']>;
  avatarURLHasPrefix?: InputMaybe<Scalars['String']>;
  avatarURLHasSuffix?: InputMaybe<Scalars['String']>;
  avatarURLIn?: InputMaybe<Array<Scalars['String']>>;
  avatarURLIsNil?: InputMaybe<Scalars['Boolean']>;
  avatarURLLT?: InputMaybe<Scalars['String']>;
  avatarURLLTE?: InputMaybe<Scalars['String']>;
  avatarURLNEQ?: InputMaybe<Scalars['String']>;
  avatarURLNotIn?: InputMaybe<Array<Scalars['String']>>;
  avatarURLNotNil?: InputMaybe<Scalars['Boolean']>;
  /** bio field predicates */
  bio?: InputMaybe<Scalars['String']>;
  bioContains?: InputMaybe<Scalars['String']>;
  bioContainsFold?: InputMaybe<Scalars['String']>;
  bioEqualFold?: InputMaybe<Scalars['String']>;
  bioGT?: InputMaybe<Scalars['String']>;
  bioGTE?: InputMaybe<Scalars['String']>;
  bioHasPrefix?: InputMaybe<Scalars['String']>;
  bioHasSuffix?: InputMaybe<Scalars['String']>;
  bioIn?: InputMaybe<Array<Scalars['String']>>;
  bioIsNil?: InputMaybe<Scalars['Boolean']>;
  bioLT?: InputMaybe<Scalars['String']>;
  bioLTE?: InputMaybe<Scalars['String']>;
  bioNEQ?: InputMaybe<Scalars['String']>;
  bioNotIn?: InputMaybe<Array<Scalars['String']>>;
  bioNotNil?: InputMaybe<Scalars['Boolean']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']>;
  emailContains?: InputMaybe<Scalars['String']>;
  emailContainsFold?: InputMaybe<Scalars['String']>;
  emailEqualFold?: InputMaybe<Scalars['String']>;
  emailGT?: InputMaybe<Scalars['String']>;
  emailGTE?: InputMaybe<Scalars['String']>;
  emailHasPrefix?: InputMaybe<Scalars['String']>;
  emailHasSuffix?: InputMaybe<Scalars['String']>;
  emailIn?: InputMaybe<Array<Scalars['String']>>;
  emailLT?: InputMaybe<Scalars['String']>;
  emailLTE?: InputMaybe<Scalars['String']>;
  emailNEQ?: InputMaybe<Scalars['String']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** full_name field predicates */
  fullName?: InputMaybe<Scalars['String']>;
  fullNameContains?: InputMaybe<Scalars['String']>;
  fullNameContainsFold?: InputMaybe<Scalars['String']>;
  fullNameEqualFold?: InputMaybe<Scalars['String']>;
  fullNameGT?: InputMaybe<Scalars['String']>;
  fullNameGTE?: InputMaybe<Scalars['String']>;
  fullNameHasPrefix?: InputMaybe<Scalars['String']>;
  fullNameHasSuffix?: InputMaybe<Scalars['String']>;
  fullNameIn?: InputMaybe<Array<Scalars['String']>>;
  fullNameIsNil?: InputMaybe<Scalars['Boolean']>;
  fullNameLT?: InputMaybe<Scalars['String']>;
  fullNameLTE?: InputMaybe<Scalars['String']>;
  fullNameNEQ?: InputMaybe<Scalars['String']>;
  fullNameNotIn?: InputMaybe<Array<Scalars['String']>>;
  fullNameNotNil?: InputMaybe<Scalars['Boolean']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<UserWhereInput>;
  or?: InputMaybe<Array<UserWhereInput>>;
  /** password_hash field predicates */
  passwordHash?: InputMaybe<Scalars['String']>;
  passwordHashContains?: InputMaybe<Scalars['String']>;
  passwordHashContainsFold?: InputMaybe<Scalars['String']>;
  passwordHashEqualFold?: InputMaybe<Scalars['String']>;
  passwordHashGT?: InputMaybe<Scalars['String']>;
  passwordHashGTE?: InputMaybe<Scalars['String']>;
  passwordHashHasPrefix?: InputMaybe<Scalars['String']>;
  passwordHashHasSuffix?: InputMaybe<Scalars['String']>;
  passwordHashIn?: InputMaybe<Array<Scalars['String']>>;
  passwordHashLT?: InputMaybe<Scalars['String']>;
  passwordHashLTE?: InputMaybe<Scalars['String']>;
  passwordHashNEQ?: InputMaybe<Scalars['String']>;
  passwordHashNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** username field predicates */
  username?: InputMaybe<Scalars['String']>;
  usernameContains?: InputMaybe<Scalars['String']>;
  usernameContainsFold?: InputMaybe<Scalars['String']>;
  usernameEqualFold?: InputMaybe<Scalars['String']>;
  usernameGT?: InputMaybe<Scalars['String']>;
  usernameGTE?: InputMaybe<Scalars['String']>;
  usernameHasPrefix?: InputMaybe<Scalars['String']>;
  usernameHasSuffix?: InputMaybe<Scalars['String']>;
  usernameIn?: InputMaybe<Array<Scalars['String']>>;
  usernameLT?: InputMaybe<Scalars['String']>;
  usernameLTE?: InputMaybe<Scalars['String']>;
  usernameNEQ?: InputMaybe<Scalars['String']>;
  usernameNotIn?: InputMaybe<Array<Scalars['String']>>;
};

export type UserWithAuth = {
  __typename?: 'UserWithAuth';
  access_token: Scalars['String'];
  expired_at: Scalars['Time'];
  user: User;
};

export type UserByAccessTokenQueryVariables = Exact<{
  token: Scalars['String'];
}>;


export type UserByAccessTokenQuery = { __typename?: 'Query', UserByAccessToken: { __typename?: 'UserWithAuth', access_token: string, expired_at: any, user: { __typename?: 'User', id: string, username: string, email: string, full_name?: string | null, avatar_url?: string | null, bio?: string | null, created_at: any, updated_at: any } } };

export type SignUpMutationVariables = Exact<{
  input: CreateUserInput;
}>;


export type SignUpMutation = { __typename?: 'Mutation', SignUp: { __typename?: 'UserWithAuth', access_token: string, expired_at: any, user: { __typename?: 'User', id: string, username: string, email: string, full_name?: string | null, avatar_url?: string | null, bio?: string | null, created_at: any, updated_at: any } } };

export type SignInWithUsernameMutationVariables = Exact<{
  input: SignInWithUsername;
}>;


export type SignInWithUsernameMutation = { __typename?: 'Mutation', SignInWithUsername: { __typename?: 'UserWithAuth', access_token: string, expired_at: any, user: { __typename?: 'User', id: string, username: string, email: string, full_name?: string | null, avatar_url?: string | null, bio?: string | null, created_at: any, updated_at: any } } };

export type SignInWithEmailMutationVariables = Exact<{
  input: SignInWithEmail;
}>;


export type SignInWithEmailMutation = { __typename?: 'Mutation', SignInWithEmail: { __typename?: 'UserWithAuth', access_token: string, expired_at: any, user: { __typename?: 'User', id: string, username: string, email: string, full_name?: string | null, avatar_url?: string | null, bio?: string | null, created_at: any, updated_at: any } } };

export type UserFieldsFragment = { __typename?: 'User', id: string, username: string, email: string, full_name?: string | null, avatar_url?: string | null, bio?: string | null, created_at: any, updated_at: any };

export type UserWithAuthFieldsFragment = { __typename?: 'UserWithAuth', access_token: string, expired_at: any, user: { __typename?: 'User', id: string, username: string, email: string, full_name?: string | null, avatar_url?: string | null, bio?: string | null, created_at: any, updated_at: any } };

export const UserFieldsFragmentDoc = gql`
    fragment UserFields on User {
  id
  username
  email
  full_name
  avatar_url
  bio
  created_at
  updated_at
}
    `;
export const UserWithAuthFieldsFragmentDoc = gql`
    fragment UserWithAuthFields on UserWithAuth {
  access_token
  expired_at
  user {
    ...UserFields
  }
}
    ${UserFieldsFragmentDoc}`;
export const UserByAccessTokenDocument = gql`
    query UserByAccessToken($token: String!) {
  UserByAccessToken(token: $token) {
    ...UserWithAuthFields
  }
}
    ${UserWithAuthFieldsFragmentDoc}`;

export function useUserByAccessTokenQuery(options: Omit<Urql.UseQueryArgs<UserByAccessTokenQueryVariables>, 'query'>) {
  return Urql.useQuery<UserByAccessTokenQuery>({ query: UserByAccessTokenDocument, ...options });
};
export const SignUpDocument = gql`
    mutation SignUp($input: CreateUserInput!) {
  SignUp(input: $input) {
    ...UserWithAuthFields
  }
}
    ${UserWithAuthFieldsFragmentDoc}`;

export function useSignUpMutation() {
  return Urql.useMutation<SignUpMutation, SignUpMutationVariables>(SignUpDocument);
};
export const SignInWithUsernameDocument = gql`
    mutation SignInWithUsername($input: SignInWithUsername!) {
  SignInWithUsername(input: $input) {
    ...UserWithAuthFields
  }
}
    ${UserWithAuthFieldsFragmentDoc}`;

export function useSignInWithUsernameMutation() {
  return Urql.useMutation<SignInWithUsernameMutation, SignInWithUsernameMutationVariables>(SignInWithUsernameDocument);
};
export const SignInWithEmailDocument = gql`
    mutation SignInWithEmail($input: SignInWithEmail!) {
  SignInWithEmail(input: $input) {
    ...UserWithAuthFields
  }
}
    ${UserWithAuthFieldsFragmentDoc}`;

export function useSignInWithEmailMutation() {
  return Urql.useMutation<SignInWithEmailMutation, SignInWithEmailMutationVariables>(SignInWithEmailDocument);
};